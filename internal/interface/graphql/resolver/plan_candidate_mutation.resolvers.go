package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"fmt"
	"poroto.app/poroto/planner/internal/domain/array"

	"github.com/google/uuid"
	"go.uber.org/zap"
	"poroto.app/poroto/planner/internal/domain/models"
	"poroto.app/poroto/planner/internal/domain/services/plancandidate"
	"poroto.app/poroto/planner/internal/domain/services/plangen"
	"poroto.app/poroto/planner/internal/domain/utils"
	"poroto.app/poroto/planner/internal/interface/graphql/factory"
	"poroto.app/poroto/planner/internal/interface/graphql/model"
)

// CreatePlanByLocation is the resolver for the createPlanByLocation field.
func (r *mutationResolver) CreatePlanByLocation(ctx context.Context, input model.CreatePlanByLocationInput) (*model.CreatePlanByLocationOutput, error) {
	// TODO: 必須パラメータにする
	createBasedOnCurrentLocation := false
	if input.CreatedBasedOnCurrentLocation != nil {
		createBasedOnCurrentLocation = *input.CreatedBasedOnCurrentLocation
	}

	locationStart := models.GeoLocation{
		Latitude:  input.Latitude,
		Longitude: input.Longitude,
	}

	// プラン候補の作成
	var planCandidateSetId string
	if input.Session != nil {
		planCandidateSetId = *input.Session
	} else {
		planCandidateSetId = uuid.New().String()
		if err := r.PlanCandidateService.CreatePlanCandidateSet(ctx, planCandidateSetId); err != nil {
			r.Logger.Error("error while creating plan candidate", zap.Error(err))
			return nil, fmt.Errorf("internal server error")
		}
	}

	// プランの作成
	plans, err := r.PlanGenService.CreatePlanByLocation(
		ctx,
		plangen.CreatePlanByLocationInput{
			PlanCandidateSetId:           planCandidateSetId,
			LocationStart:                locationStart,
			GooglePlaceId:                input.GooglePlaceID,
			CategoryNamesPreferred:       &input.CategoriesPreferred,
			CategoryNamesDisliked:        &input.CategoriesDisliked,
			FreeTime:                     input.FreeTime,
			CreateBasedOnCurrentLocation: createBasedOnCurrentLocation,
			ShouldOpenWhileTraveling:     false,
		},
	)
	if err != nil {
		r.Logger.Error("error while creating plan by location", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	// 作成されたプランの保存
	if err := r.PlanCandidateService.SavePlans(ctx, plancandidate.SavePlansInput{
		PlanCandidateSetId:           planCandidateSetId,
		Plans:                        *plans,
		LocationStart:                &locationStart,
		CategoryNamesPreferred:       &input.CategoriesPreferred,
		CategoryNamesRejected:        &input.CategoriesDisliked,
		FreeTime:                     input.FreeTime,
		CreateBasedOnCurrentLocation: createBasedOnCurrentLocation,
	}); err != nil {
		r.Logger.Error("error while saving plans", zap.Error(err))
	}

	return &model.CreatePlanByLocationOutput{
		Session: planCandidateSetId,
		Plans:   factory.PlansFromDomainModel(plans, &locationStart),
	}, nil
}

// CreatePlanByPlace is the resolver for the createPlanByPlace field.
func (r *mutationResolver) CreatePlanByPlace(ctx context.Context, input model.CreatePlanByPlaceInput) (*model.CreatePlanByPlaceOutput, error) {
	planCreated, err := r.PlanGenService.CreatePlanFromPlace(
		ctx,
		input.Session,
		input.PlaceID,
	)
	if err != nil {
		r.Logger.Error("error while creating plan by place", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	graphqlPlan, err := factory.PlanFromDomainModel(*planCreated, nil)
	if err != nil {
		r.Logger.Error("error while converting plan to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.CreatePlanByPlaceOutput{
		Plan: graphqlPlan,
	}, nil
}

// CreatePlanByCategory is the resolver for the createPlanByCategory field.
func (r *mutationResolver) CreatePlanByCategory(ctx context.Context, input model.CreatePlanByCategoryInput) (*model.CreatePlanByCategoryOutput, error) {
	r.Logger.Info(
		"CreatePlanByCategory",
		zap.String("category", input.CategoryID),
		zap.Float64("latitude", input.Latitude),
		zap.Float64("longitude", input.Longitude),
		zap.Float64("radius", input.RadiusInKm),
	)

	planCandidateSetId := uuid.New().String()
	if err := r.PlanCandidateService.CreatePlanCandidateSet(ctx, planCandidateSetId); err != nil {
		r.Logger.Error("error while creating plan candidate", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	category, ok := array.Find(
		array.FlatMap(models.GetAllLocationCategorySetCreatePlan(), func(s models.LocationCategorySetCreatePlan) []models.LocationCategoryCreatePlan {
			return s.Categories
		}),
		func(c models.LocationCategoryCreatePlan) bool {
			return c.Id == input.CategoryID
		},
	)
	if !ok {
		r.Logger.Error("invalid category id", zap.String("category", input.CategoryID))
		return nil, fmt.Errorf("invalid category id")
	}

	plans, err := r.PlanGenService.CreatePlanByCategory(
		ctx,
		plangen.CreatePlanByCategoryInput{
			PlanCandidateSetId: planCandidateSetId,
			Category:           category,
			Location: models.GeoLocation{
				Latitude:  input.Latitude,
				Longitude: input.Longitude,
			},
			RadiusInKm: input.RadiusInKm,
		},
	)
	if err != nil {
		r.Logger.Error("error while creating plan by category", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	if err := r.PlanCandidateService.SavePlans(ctx, plancandidate.SavePlansInput{
		PlanCandidateSetId: planCandidateSetId,
		Plans:              *plans,
		LocationStart: &models.GeoLocation{
			Latitude:  input.Latitude,
			Longitude: input.Longitude,
		},
		CategoryNamesPreferred: &[]string{category.Id},
	}); err != nil {
		r.Logger.Error("error while saving plans", zap.Error(err))
	}

	return &model.CreatePlanByCategoryOutput{
		PlanCandidateSetID: planCandidateSetId,
		Plans:              factory.PlansFromDomainModel(plans, nil),
	}, nil
}

// CreatePlanCandidateSetFromSavedPlan is the resolver for the createPlanCandidateSetFromSavedPlan field.
func (r *mutationResolver) CreatePlanCandidateSetFromSavedPlan(ctx context.Context, input model.CreatePlanCandidateSetFromSavedPlanInput) (*model.CreatePlanCandidateSetFromSavedPlanOutput, error) {
	r.Logger.Info(
		"CreatePlanCandidateSetFromSavedPlan",
		zap.String("planId", input.SavedPlanID),
		zap.String("userId", utils.StrEmptyIfNil(input.UserID)),
		zap.String("firebaseAuthToken", utils.StrEmptyIfNil(input.FirebaseAuthToken)),
	)

	output, err := r.PlanCandidateService.CreatePlanCandidateSetFromSavedPlan(ctx, plancandidate.CreatePlanCandidateSetFromSavedPlanInput{
		PlanId:            input.SavedPlanID,
		UserId:            input.UserID,
		FirebaseAuthToken: input.FirebaseAuthToken,
	})
	if err != nil {
		r.Logger.Error("error while creating plan candidate set from saved plan", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	planGraphQLModel := factory.PlanCandidateSetFromDomainModel(&output.PlanCandidateSet)

	if err != nil {
		r.Logger.Error("error while converting plan domain model to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.CreatePlanCandidateSetFromSavedPlanOutput{
		PlanCandidate: planGraphQLModel,
	}, nil
}

// ChangePlacesOrderInPlanCandidate is the resolver for the changePlacesOrderInPlanCandidate field.
func (r *mutationResolver) ChangePlacesOrderInPlanCandidate(ctx context.Context, input model.ChangePlacesOrderInPlanCandidateInput) (*model.ChangePlacesOrderInPlanCandidateOutput, error) {
	planUpdated, err := r.PlanCandidateService.ChangePlacesOrderPlanCandidateSet(ctx, input.PlanID, input.Session, input.PlaceIds)
	if err != nil {
		return nil, fmt.Errorf("could not change places order")
	}

	planCandidate, err := r.PlanCandidateService.Find(ctx, plancandidate.FindPlanCandidateSetInput{
		PlanCandidateSetId: input.Session,
	})
	if err != nil {
		r.Logger.Error("error while finding plan candidate", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	graphqlPlan, err := factory.PlanFromDomainModel(*planUpdated, planCandidate.MetaData.GetLocationStart())
	if err != nil {
		r.Logger.Error("error while converting plan to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.ChangePlacesOrderInPlanCandidateOutput{
		Plan: graphqlPlan,
	}, nil
}

// SavePlanFromCandidate is the resolver for the savePlanFromCandidate field.
func (r *mutationResolver) SavePlanFromCandidate(ctx context.Context, input model.SavePlanFromCandidateInput) (*model.SavePlanFromCandidateOutput, error) {
	r.Logger.Info(
		"SavePlanFromCandidate",
		zap.String("planCandidateId", input.Session),
		zap.String("planId", input.PlanID),
	)

	planSaved, err := r.PlanService.SavePlanFromPlanCandidateSet(ctx, input.Session, input.PlanID, input.AuthToken)
	if err != nil {
		r.Logger.Error("error while saving plan from plan candidate", zap.Error(err))
		return nil, fmt.Errorf("could not save plan")
	}

	graphqlPlan, err := factory.PlanFromDomainModel(*planSaved, nil)
	if err != nil {
		r.Logger.Error("error while converting plan to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.SavePlanFromCandidateOutput{
		Plan: graphqlPlan,
	}, nil
}

// AddPlaceToPlanCandidateAfterPlace is the resolver for the addPlaceToPlanCandidateAfterPlace field.
func (r *mutationResolver) AddPlaceToPlanCandidateAfterPlace(ctx context.Context, input *model.AddPlaceToPlanCandidateAfterPlaceInput) (*model.AddPlaceToPlanCandidateAfterPlaceOutput, error) {
	planInPlanCandidate, err := r.PlanCandidateService.AddPlaceAfterPlace(ctx, input.PlanCandidateID, input.PlanID, input.PreviousPlaceID, input.PlaceID)
	if err != nil {
		r.Logger.Error("error while adding place to plan candidate after place", zap.Error(err))
		return nil, fmt.Errorf("could not add place to plan candidate")
	}

	planCandidate, err := r.PlanCandidateService.Find(ctx, plancandidate.FindPlanCandidateSetInput{
		PlanCandidateSetId: input.PlanCandidateID,
	})
	if err != nil {
		r.Logger.Error("error while finding plan candidate", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	graphqlPlanInPlanCandidate, err := factory.PlanFromDomainModel(*planInPlanCandidate, planCandidate.MetaData.GetLocationStart())
	if err != nil {
		r.Logger.Error("error while converting plan to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.AddPlaceToPlanCandidateAfterPlaceOutput{
		Plan: graphqlPlanInPlanCandidate,
	}, nil
}

// DeletePlaceFromPlanCandidate is the resolver for the deletePlaceFromPlanCandidate field.
func (r *mutationResolver) DeletePlaceFromPlanCandidate(ctx context.Context, input model.DeletePlaceFromPlanCandidateInput) (*model.DeletePlaceFromPlanCandidateOutput, error) {
	planUpdated, err := r.PlanCandidateService.RemovePlaceFromPlan(ctx, input.PlanCandidateID, input.PlanID, input.PlaceID)
	if err != nil {
		r.Logger.Error("error while deleting place from plan candidate", zap.Error(err))
		return nil, fmt.Errorf("could not delete place from plan candidate")
	}

	planCandidate, err := r.PlanCandidateService.Find(ctx, plancandidate.FindPlanCandidateSetInput{
		PlanCandidateSetId: input.PlanCandidateID,
	})
	if err != nil {
		r.Logger.Error("error while finding plan candidate", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	graphqlPlanInPlanCandidate, err := factory.PlanFromDomainModel(*planUpdated, planCandidate.MetaData.GetLocationStart())
	if err != nil {
		r.Logger.Error("error while converting plan to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.DeletePlaceFromPlanCandidateOutput{
		PlanCandidateID: input.PlanCandidateID,
		Plan:            graphqlPlanInPlanCandidate,
	}, nil
}

// ReplacePlaceOfPlanCandidate is the resolver for the replacePlaceOfPlanCandidate field.
func (r *mutationResolver) ReplacePlaceOfPlanCandidate(ctx context.Context, input model.ReplacePlaceOfPlanCandidateInput) (*model.ReplacePlaceOfPlanCandidateOutput, error) {
	plan, err := r.PlanCandidateService.ReplacePlace(ctx, input.PlanCandidateID, input.PlanID, input.PlaceIDToRemove, input.PlaceIDToReplace)
	if err != nil {
		r.Logger.Error("error while replacing place of plan candidate", zap.Error(err))
		return nil, fmt.Errorf("could not replace place of plan candidate")
	}

	planCandidate, err := r.PlanCandidateService.Find(ctx, plancandidate.FindPlanCandidateSetInput{
		PlanCandidateSetId: input.PlanCandidateID,
	})
	if err != nil {
		r.Logger.Error("error while finding plan candidate", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	graphqlPlanInPlanCandidate, err := factory.PlanFromDomainModel(*plan, planCandidate.MetaData.GetLocationStart())
	if err != nil {
		r.Logger.Error("error while converting plan to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.ReplacePlaceOfPlanCandidateOutput{
		PlanCandidateID: input.PlanCandidateID,
		Plan:            graphqlPlanInPlanCandidate,
	}, nil
}

// EditPlanTitleOfPlanCandidate is the resolver for the editPlanTitleOfPlanCandidate field.
func (r *mutationResolver) EditPlanTitleOfPlanCandidate(ctx context.Context, input model.EditPlanTitleOfPlanCandidateInput) (*model.EditPlanTitleOfPlanCandidateOutput, error) {
	panic(fmt.Errorf("not implemented: EditPlanTitleOfPlanCandidate - editPlanTitleOfPlanCandidate"))
}

// AutoReorderPlacesInPlanCandidate is the resolver for the autoReorderPlacesInPlanCandidate field.
func (r *mutationResolver) AutoReorderPlacesInPlanCandidate(ctx context.Context, input model.AutoReorderPlacesInPlanCandidateInput) (*model.AutoReorderPlacesInPlanCandidateOutput, error) {
	r.Logger.Info(
		"AutoReorderPlacesInPlanCandidate",
		zap.String("planCandidateId", input.PlanCandidateID),
		zap.String("planId", input.PlanID),
	)

	planCandidateSet, err := r.PlanCandidateService.Find(ctx, plancandidate.FindPlanCandidateSetInput{
		PlanCandidateSetId: input.PlanCandidateID,
	})
	if err != nil {
		r.Logger.Error("error while finding plan candidate", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	if planCandidateSet == nil {
		r.Logger.Error("plan candidate not found", zap.String("planCandidateId", input.PlanCandidateID))
		return nil, fmt.Errorf("plan candidate not found")
	}

	planUpdated, err := r.PlanCandidateService.AutoReorderPlaces(ctx, plancandidate.AutoReorderPlacesInput{
		PlanCandidateSetId: input.PlanCandidateID,
		PlanId:             input.PlanID,
	})
	if err != nil {
		r.Logger.Error("error while auto reordering places in plan candidate", zap.Error(err))
		return nil, fmt.Errorf("could not auto reorder places in plan candidate")
	}

	graphqlPlanInPlanCandidate, err := factory.PlanFromDomainModel(*planUpdated, planCandidateSet.MetaData.GetLocationStart())
	if err != nil {
		r.Logger.Error("error while converting plan to graphql model", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	return &model.AutoReorderPlacesInPlanCandidateOutput{
		PlanCandidateID: input.PlanCandidateID,
		Plan:            graphqlPlanInPlanCandidate,
	}, nil
}

// LikeToPlaceInPlanCandidate is the resolver for the likeToPlaceInPlanCandidate field.
func (r *mutationResolver) LikeToPlaceInPlanCandidate(ctx context.Context, input model.LikeToPlaceInPlanCandidateInput) (*model.LikeToPlaceInPlanCandidateOutput, error) {
	r.Logger.Info(
		"LikeToPlaceInPlanCandidateSet",
		zap.String("planCandidateId", input.PlanCandidateID),
		zap.String("placeId", input.PlaceID),
		zap.Bool("like", input.Like),
		zap.String("userId", utils.FromPointerOrZero(input.UserID)),
	)

	planCandidateUpdated, err := r.PlanCandidateService.LikeToPlaceInPlanCandidateSet(ctx, plancandidate.LikeToPlaceInPlanCandidateSetInput{
		PlanCandidateSetId: input.PlanCandidateID,
		PlaceId:            input.PlaceID,
		Like:               input.Like,
		UserId:             input.UserID,
		FirebaseAuthToken:  input.FirebaseAuthToken,
	})
	if err != nil {
		r.Logger.Error("error while liking to place in plan candidate", zap.Error(err))
		return nil, fmt.Errorf("could not like to place in plan candidate")
	}

	graphqlPlanCandidate := factory.PlanCandidateSetFromDomainModel(planCandidateUpdated)
	return &model.LikeToPlaceInPlanCandidateOutput{
		PlanCandidate: graphqlPlanCandidate,
	}, nil
}
